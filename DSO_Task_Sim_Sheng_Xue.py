import re
import random
from time import sleep
import threading
from queue import Queue
# Email OTP module task

## Task
# 1. To implement an email OTP module that can be used for our enterprise application. You are free to use any standard library from the language which you choose to implement the test.
# 2. Do document any assumptions that you make.
# 3. Describe how you would test your module.

## pseudo code
class Email_OTP_Module:
    STATUS_EMAIL_OK = "email containing OTP has been sent successfully."
    STATUS_EMAIL_FAIL = "email address does not exist or sending to the email has failed."
    STATUS_EMAIL_INVALID = "email address is invalid."
    STATUS_OTP_OK = "OTP is valid and checked"
    STATUS_OTP_FAIL = "OTP is wrong after 10 tries"
    STATUS_OTP_TIMEOUT = "timeout after 1 min"

    # start can be called after an instance of Email OTP is constructed. Can be used to initialise variables.
    def start(self):
        self.email_regex = re.compile(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.dso\.org\.sg$')
        self.max_range = 1000000
        self.timeout = 60
        self.max_tries = 10
        self.otps = set()
        return

    # @func generate_OTP_email sends a new 6 digit random OTP code [000000 to 999999] to the given email address input by the users. Only emails from the ".dso.org.sg" domain should be allowed to receive an OTP code.
    # You can assume a function send_email(email_address, email_body) is implemented. 
    # Email body to the user should be in this format "You OTP Code is 123456. The code is valid for 1 minute"

    # @param user_email is an email address entered by the user. 

    # @returns the following status code (assume implemented as constants)
    # STATUS_EMAIL_OK: email containing OTP has been sent successfully.
    # STATUS_EMAIL_FAIL: email address does not exist or sending to the email has failed.
    # STATUS_EMAIL_INVALID: email address is invalid.  
    def generate_OTP_email(self, user_email):
        # ASSUMPTION: @dso.org.sg is considered invalid
        # ASSUMPTION: Each OTP is uniquely generated for each user, but not tied to a particular user. This is because checkOTP does not pass in the user.
        if not self.email_regex.match(user_email):
            return Email_OTP_Module.STATUS_EMAIL_INVALID

        available_numbers = [i for i in range(self.max_range)]
        excluded_numbers = self.otps
        valid_numbers = [x for x in available_numbers if x not in excluded_numbers]

        otp = str(random.choice(valid_numbers)).zfill(6)
        email_body = "Your OTP Code is %s. The code is valid for 1 minute".format(otp)

        try:
            self.send_email(user_email, email_body)
            self.otps.add(otp)
        except Exception as e:
            return Email_OTP_Module.STATUS_EMAIL_FAIL

        return Email_OTP_Module.STATUS_EMAIL_OK

    # @func check_OTP reads the input stream for user input of the OTP. The OTP to match if the current OTP generated by a send
    # allows user 10 tries to enter the valid OTP. check_OTP should return after 1min is the user does not give a valid OTP. 

    # @param input is a generic IOstream. It implements input.readOTP() which waits and returns the 6 digit entered by the user. this function call is blocking so you might need to wrap it in a timeout.

    # @returns the following status code (assume implemented as constants)
    # STATUS_OTP_OK: OTP is valid and checked
    # STATUS_OTP_FAIL: OTP is wrong after 10 tries
    # STATUS_OTP_TIMEOUT: timeout after 1 min
    def check_OTP(self, input):
        # ASSUMPTION: The timeout is for each try of a user entering the OTP.
        # ASSUMPTION: The user is not allowed any more tries if any single try exceeds the time of 1 min.
        # ASSUMPTION: It is considered a success if the user returns any currently valid otp. This is because checkOTP does not pass in the user.
        for _ in range(self.max_tries):
            t = threading.Thread(target=input.readOTP)
            t.start()
            t.join(self.timeout)
            if t.is_alive():
                return Email_OTP_Module.STATUS_OTP_TIMEOUT
            try:
                otp = input.q.get()
                if otp in self.otps:
                    self.otps.remove(otp)
                    return Email_OTP_Module.STATUS_OTP_OK
            except Exception as e:
                return Email_OTP_Module.STATUS_OTP_FAIL
        return Email_OTP_Module.STATUS_OTP_FAIL
    
    # Functions below for testing
    def send_email(self, user_email, email_body):
        # Uncomment for test case 5:
        # raise ValueError("Failed to send email")
        return

# For testing
class Input:
    def __init__(self):
        self.q = Queue()
        
    def readOTP(self):
        # Uncomment for test case 7:
        # sleep(100)
        result = 1
        self.q.put(result)
        return
    
# Test case 1: Generate OTP for valid email address
# Input: "a@b.dso.org.sg"
# Expected output: STATUS_EMAIL_OK, email containing OTP has been sent successfully.
e = Email_OTP_Module()
e.start()
print("Test case 1: ", e.generate_OTP_email("a@b.dso.org.sg"))

# Test case 2: Send OTP email successfully (variant)
# Input: "john@cc-dd.dso.org.sg"
# Expected output: STATUS_EMAIL_OK, sent successfully
e = Email_OTP_Module()
e.start()
print("Test case 2: ", e.generate_OTP_email("john@cc-dd.dso.org.sg"))

# Test case 3: Generate OTP for invalid email address
# Input: "a@bb_b"
# Expected output: STATUS_EMAIL_INVALID, email address is invalid.
e = Email_OTP_Module()
e.start()
print("Test case 3: ", e.generate_OTP_email("a@bb_b"))

# Test case 4: Generate OTP for email address not in .dso.org.sg domain
# Input: "john@gmail.com"
# Expected output: STATUS_EMAIL_INVALID, email address is invalid.
e = Email_OTP_Module()
e.start()
print("Test case 4: ", e.generate_OTP_email("john@gmail.com"))

# Test case 5: Fail to send OTP email due to internal error (Need to uncomment ValueError exception)
# Input: "john@b.dso.org.sg"
# Expected output: STATUS_EMAIL_FAIL, email address does not exist or sending to the email has failed.
e = Email_OTP_Module()
e.start()
print("Test case 5: ", e.generate_OTP_email("john@b.dso.org.sg"))

# Test case 6: Fail to read valid OTP within 10 tries
# Input: "john@b.dso.org.sg"
# Expected output: STATUS_OTP_FAIL, OTP is wrong after 10 tries.
e = Email_OTP_Module()
e.start()
e.generate_OTP_email("john@b.dso.org.sg")
print("Test case 6: ", e.check_OTP(Input()))

# Test case 7: Time out after 1 minute of waiting for user input (Need to uncomment sleep)
# Input: "john@b.dso.org.sg"
# Expected output: STATUS_OTP_TIMEOUT, timeout after 1 min.
e = Email_OTP_Module()
e.start()
e.generate_OTP_email("john@b.dso.org.sg")
print("Test case 7: ", e.check_OTP(Input()))

# Test case 8: Valid OTP
# Input: Modify input.readOTP to return the correct OTP sent to the user, and within the timeout
# Expected output: STATUS_OTP_OK, successfully checked OTP

# Test case 9: Handle multiple concurrent requests to generate and check OTPs
# Input: multiple requests to generate and check OTPs at the same time
# Expected output: each request should be handled independently and return the correct status.